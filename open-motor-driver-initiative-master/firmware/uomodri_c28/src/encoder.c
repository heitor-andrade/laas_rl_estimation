/***********************************************************************
 * INCLUDE
 ***********************************************************************/
#ifdef CPU1
#include "f2838x_device.h"
#include "driverlib.h"
#include "device.h"
#else
#include "driverlib_cm.h"
#include "cm.h"
#endif
#include "encoder.h"

/***********************************************************************
 * DEFINES
 ***********************************************************************/
// This threshold corresponds to the middle speed for low/high speed estimation merge
// See the ENC_update function for more details
#define SPEED_ESTIMATION_THRESHOLD      80.4f // [rad/s]
#define MAX_ROLLOVER                    (127)
#define MIN_ROLLOVER                    (-128)

/***********************************************************************
 * FUNCTIONS DEFINITIONS
 ***********************************************************************/
/**
 * @brief           Reset the ENCODER structure
 * @param[inout]    *p_enc   Pointer on the ENCODER structure to reset.
 */
void ENC_resetStruct(encoder_t* p_enc)
{
    speed_t* p_speed        = &p_enc->speed;

    p_enc->thetaMech[NEW]   = 0.0f;
    p_enc->thetaMech[OLD]   = 0.0f;
    p_enc->thetaElec        = 0.0f;
    p_enc->thetaIndex       = 0.0f;
    p_enc->thetaAbsolute    = 0.0f;
    p_enc->turnNb           = 0U;
    p_enc->indexDetect      = false;
    p_enc->indexOffset      = false;
    p_enc->indexToggle      = false;
    p_enc->indexError       = false;
    p_enc->rollOverError    = false;

    p_speed->alpha          = 0.0f;
//    p_speed->speedRef       = 0.0f;
    p_speed->theta[NEW]     = 0.0f;
    p_speed->theta[OLD]     = 0.0f;
    p_speed->speedHigh      = 0.0f;
    p_speed->speedLow       = 0.0f;
    p_speed->speedMech[0]   = 0.0f;
    p_speed->speedMech[1]   = 0.0f;
    p_speed->speedElec      = 0.0f;

    return;
}

/**
 * @brief           Reset the quadrature encoder peripheral (eQEP)
 * @param[inout]    *p_enc   Pointer on the ENCODER structure to reset.
 */
inline void ENC_resetPeriph(encoder_t* p_enc)
{
    uint32_t eqepBase       = p_enc->p_qepHandle->eqepBase;
    // Reset encoder position
    EQEP_setPosition(eqepBase, 0);
    /* Reset the time base for edge capture unit */
    HWREGH(eqepBase + EQEP_O_QCPRDLAT) = 0;
    /* Reset the Period count */
    HWREGH(eqepBase + EQEP_O_QCTMRLAT) = 0;
    // Reset interrupts status flags
    EQEP_clearInterruptStatus(eqepBase, (EQEP_INT_GLOBAL | EQEP_INT_POS_CNT_ERROR | EQEP_INT_PHASE_ERROR |
            EQEP_INT_DIR_CHANGE | EQEP_INT_WATCHDOG | EQEP_INT_UNDERFLOW | EQEP_INT_OVERFLOW |
            EQEP_INT_POS_COMP_READY | EQEP_INT_POS_COMP_MATCH | EQEP_INT_STROBE_EVNT_LATCH |
            EQEP_INT_INDEX_EVNT_LATCH | EQEP_INT_UNIT_TIME_OUT | EQEP_INT_QMA_ERROR));
    // Reset general status flags
    EQEP_clearStatus(eqepBase, (EQEP_STS_UNIT_POS_EVNT | EQEP_STS_CAP_OVRFLW_ERROR | EQEP_STS_CAP_DIR_ERROR | EQEP_STS_1ST_IDX_FLAG));

    return;
}

/**
 * @brief           Read the position latched on ADCSOC event (generated by PWM SOC), direction \& electric position
 * @param[inout]    *p_enc  Pointer on the encoder structure.
 */
inline void ENC_getPosition(encoder_t* p_enc)
{
    uint32_t eqepBase       = p_enc->p_qepHandle->eqepBase;
    p_enc->thetaMech[OLD]   = p_enc->thetaMech[NEW];
    // Compute mechanical angle normalized between 0 and 1
    p_enc->thetaMech[NEW]   = (float32_t)EQEP_getStrobePositionLatch(eqepBase) * p_enc->thetaMechScaler;
    // Get direction : -1 = CCW/reverse, 1 = CW/forward
    p_enc->thetaDir         = EQEP_getDirection(eqepBase);
    // Compute electrical angle (each pole pair is normalized between 0 and 1)
    float32_t thetaElec     = (float32_t)p_enc->polePairs * p_enc->thetaMech[NEW];
#ifdef CPU1
    p_enc->thetaElec        = __mpy2pif32(__fracf32(thetaElec));
    p_enc->thetaMech[NEW]   = __mpy2pif32(p_enc->thetaMech[NEW]);
#else
    p_enc->thetaElec        = __mpy2pif32(p_enc->thetaElec - (float32_t)((int32_t)thetaElec));
    p_enc->thetaMech[NEW]   = __mpy2pif32(p_enc->thetaMech[NEW]);
#endif

    return;
}

/**
 * @brief           Encoder speed estimation
 * @param[inout]    *p_enc   Pointer on the ENCODER structure to use for speed estimate.
 */
inline void ENC_getSpeed(encoder_t* p_enc)
{
    uint32_t eqepBase           = p_enc->p_qepHandle->eqepBase;
    speed_t* p_speed            = &p_enc->speed;
//    bool_t newSpeedHigh         = false;
//    bool_t newSpeedLow          = false;
    //-------------------------------------------------------------------
    //     HIGH SPEED ESTIMATION
    //-------------------------------------------------------------------
    if(EQEP_getInterruptStatus(eqepBase) & EQEP_INT_UNIT_TIME_OUT)
    {
        p_speed->theta[OLD]     = p_speed->theta[NEW];
        p_speed->theta[NEW]     = __mpy2pif32((float32_t)EQEP_getPositionLatch(eqepBase) * p_enc->thetaMechScaler);
        EQEP_clearInterruptStatus(eqepBase, (EQEP_INT_UNIT_TIME_OUT));// | EQEP_INT_OVERFLOW | EQEP_INT_UNDERFLOW));
        // Compute angle difference
        float32_t deltaTheta    = p_speed->theta[NEW] - p_speed->theta[OLD];
        // Saturate it between -pi and pi
        deltaTheta              = (deltaTheta > M_PI)   ? (deltaTheta - (2.0f * M_PI)) : (deltaTheta);
        deltaTheta              = (deltaTheta < -M_PI)  ? (deltaTheta + (2.0f * M_PI)) : (deltaTheta);
        // Compute high speed estimation
        p_speed->speedHigh      = deltaTheta * p_speed->speedHighScaler;
//        newSpeedHigh            = true;
    }
    //-------------------------------------------------------------------
    //     LOW SPEED ESTIMATION
    //-------------------------------------------------------------------
    // Check if unit position event occurred for low speed calculation
    if(EQEP_getStatus(eqepBase) & EQEP_STS_UNIT_POS_EVNT)//if(p_qepRegs->QEPSTS.all & EQEP_STS_UNIT_POS_EVNT)
    {
        uint16_t period         = EQEP_getCapturePeriodLatch(eqepBase);
        p_speed->speedLow       = (period != 0xFFFF) ? ((float32_t)(p_enc->thetaDir) * p_speed->speedLowScaler / (float32_t)period) : (p_speed->speedLow);
//        p_speed->speedLow       = (float32_t)(p_enc->thetaDir) * p_speed->speedLowScaler / (float32_t)EQEP_getCapturePeriodLatch(eqepBase);
        // Speed is very close to zero because direction changed or the rotor doesn't move fast enough
        p_speed->speedLow       = (EQEP_getStatus(eqepBase) & (EQEP_STS_CAP_OVRFLW_ERROR | EQEP_STS_CAP_DIR_ERROR)) ? (0.0f) : (p_speed->speedLow);
        // Clear position event, direction change and timer overflow flags (even if direction and timer overflow are not set)
        EQEP_clearStatus(eqepBase, (EQEP_STS_UNIT_POS_EVNT | EQEP_STS_CAP_OVRFLW_ERROR | EQEP_STS_CAP_DIR_ERROR));
//        newSpeedLow             = true;
    }
    //-------------------------------------------------------------------
    //     SPEED ESTIMATION MERGE
    //-------------------------------------------------------------------
    /*
     *
     *
     *                  Merge coefficient shape:
     * low speed     ________
     *                      |\
     *                        \
     *                      |  \
     *                          \
     *                      |    \________      w1 = 70.8 rad/s
     * high speed                |              w2 = 90.7 rad/s
     *                      w1   w2
     *
     *  High speed estimation is used for this decision because this estimation can only be lower
     */

// Compute merge coefficient // TODO as no merge is computed alpha term is not necessary
//    speedEst.alpha = FMINMAX((0.05f * (FM_ABS(speedEst.highSpeed) - SPEED_ESTIMATION_THRESHOLD)), 1.0f, 0.0f);//    speedEst.alpha = __fmin(__fmax(0.05f * (FM_ABS(speedEst.highSpeed) - SPEED_ESTIMATION_THRESHOLD), 0.0f), 1.0f);
// Compute speed reference // TODO merge high & low speed - CSDT
// see : http://www.diegm.uniud.it/petrella/Azionamenti%20Elettrici%20II/Tesine/Petrella%20et%20al.%20-%20Speed%20Measurement%20Algorithms%20for%20Low-Resolution%20Incremental%20Encoder%20Equipped%20Drives_a%20Comparative%20Analysis.pdf
    // Compute merge coefficient
//    p_speed->alpha              = __fsat((float32_t)(0.05f * (fabs(p_speed->speedHigh) - SPEED_ESTIMATION_THRESHOLD)), 1.0f, 0.0f);
//    if(newSpeedHigh)
//    {
    float32_t speedFusion   = p_speed->speedHigh;//    p_enc->speedEst.speedRef = (1.0f - p_enc->speedEst.alpha) * p_enc->speedEst.lowMechSpeedEst + p_enc->speedEst.alpha * p_enc->speedEst.highMechSpeedEst;
    UOMODRI_SPEED_FLT(p_speed->speedFlt[0], p_speed->speedMech[0], speedFusion);
    UOMODRI_SPEED_FLT(p_speed->speedFlt[1], p_speed->speedMech[1], speedFusion);
    //    p_speed->speedMech         = p_speed->speedHigh;//speedFusion;
    p_speed->speedElec      = (float32_t)p_enc->polePairs * p_speed->speedMech[0];
//    }

    return;
}

/**
 * @brief           Encoder multi-turn \& index computation
 * @param[inout]    *p_enc   Pointer on the ENCODER structure to use for turn counting \index detection.
 */
inline void ENC_getTheta(encoder_t* p_enc)
{
    uint32_t eqepBase           = p_enc->p_qepHandle->eqepBase;
    //-------------------------------------------------------------------
    //     TURN COMPUTATION
    //-------------------------------------------------------------------
    float32_t deltaThetaMech    = p_enc->thetaMech[NEW] - p_enc->thetaMech[OLD];
    // Update turnNb
    p_enc->turnNb               = (deltaThetaMech > M_PI)   ? (p_enc->turnNb - 1) : (p_enc->turnNb);
    p_enc->turnNb               = (deltaThetaMech < -M_PI)  ? (p_enc->turnNb + 1) : (p_enc->turnNb);
    // If theta difference is high or low enough, we overflowed or underflowed
    bool_t maxRollOver          = (p_enc->turnNb > MAX_ROLLOVER)? (true) : (false);
    bool_t minRollOver          = (p_enc->turnNb < MIN_ROLLOVER)? (true) : (false);
    p_enc->rollOverError        = (maxRollOver || minRollOver)  ? (true) : (false);
    // Saturate turnNb between -128 and 127
    p_enc->turnNb               = (maxRollOver) ? (MIN_ROLLOVER) : (p_enc->turnNb);
    p_enc->turnNb               = (minRollOver) ? (MAX_ROLLOVER) : (p_enc->turnNb);
    //-------------------------------------------------------------------
    //     INDEX HANDLING
    //-------------------------------------------------------------------
    if(EQEP_getInterruptStatus(eqepBase) & EQEP_INT_INDEX_EVNT_LATCH)
    {
        // Compute indexed mechanical angle normalized between 0 and 2 x PI
        float32_t thetaIndex    = __mpy2pif32((float32_t)EQEP_getIndexPositionLatch(eqepBase) * p_enc->thetaMechScaler);
        // Save first indexed mechanical angle normalized between 0 and 2 x PI
        p_enc->thetaIndex       = (!p_enc->indexDetect) ? (thetaIndex) : (p_enc->thetaIndex);
        // Set index detection flag.
        p_enc->indexDetect      = true;
        // Check if current index capture match the first index capture
        p_enc->indexError       = (fabsf(p_enc->thetaIndex - thetaIndex) < __mpy2pif32(4.0f / p_enc->thetaMechScaler)) ? (false) : (true);
        // Toggle index
        p_enc->indexToggle      = !p_enc->indexToggle;
        // Clear flag
        EQEP_clearInterruptStatus(eqepBase, EQEP_INT_INDEX_EVNT_LATCH);
    }
    // Compute new absolute angle
    p_enc->thetaAbsolute        = p_enc->thetaMech[NEW] + __mpy2pif32((float32_t)p_enc->turnNb);

    return;
}
